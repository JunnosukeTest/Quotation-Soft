function parseItems(lines){
  // まずは行を正規化しつつ配列化（行番号を保持）
  const rows = lines.map((raw, i) => ({ i, s: normLine(raw || "") }));

  // 1) ラベル付き1行完結 例:
  //    "1 (品名)コントローラー (型式)MFC-S008 (数量)1 台 (仕切)187,000 ()187,000"
  //    "1 (品名)A (型式)B (数量)3 個 (仕切)12,000 (金額)36,000"
  const labeledRe =
    /^\s*(\d+)\s*\(品名\)\s*(.+?)\s*\(型式\)\s*([^\s]+)\s*\(数量\)\s*(\d+)\s*([^\s]+)\s*\(仕切\)\s*([¥￥]?\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*(?:\((?:金額)?\)\s*([¥￥]?\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?)\s*)?$/;

  // 2) 通常の数値行 ＋ 近傍の説明行（従来ロジック）
  const numLine = /^(\d+)\s+(\d+(?:\s*(?:式|個|台))?)\b.*$/;
  // 3) 金額と説明が隣接でもOK（例: "9 5,000梱包・運搬費"）
  const lump    = /^(\d+)\s*([¥￥]?\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?)(.*)$/;
  const skip    = /^(合\s*計|項目|品名|御\s*見\s*積|納\s*期|有\s*効|支\s*払)/;

  // 種別付け
  const kinds = rows.map(r => {
    if (labeledRe.test(r.s)) return { ...r, kind: 'labeled' };
    if (numLine.test(r.s))   return { ...r, kind: 'num' };
    if (lump.test(r.s))      return { ...r, kind: 'lump' };
    if (skip.test(r.s))      return { ...r, kind: 'skip' };
    return { ...r, kind: 'desc' };
  });

  const items = [];

  // --- まず「ラベル付き」行を全部処理（最優先）---
  for(const r of kinds){
    if(r.kind !== 'labeled') continue;
    const m = r.s.match(labeledRe);
    const idx   = Number(m[1]);
    const name  = m[2].trim();
    const model = m[3].trim();
    const qty   = Number(m[4]) || 0;
    const qUnit = (m[5] || "").trim();
    const unit  = toInt(m[6]);
    const amtRaw = m[7];
    const amount = amtRaw ? toInt(amtRaw) : (qty * unit);
    items.push({ idx, name, model, qty, qUnit, unit, amount });
  }

  // 近傍説明探索で使うセット（説明行の重複使用を避ける）
  const usedDesc = new Set();
  function findNearestDesc(pos){
    const N = kinds.length;
    for(let radius=1; radius<=8; radius++){
      const left  = pos - radius;
      const right = pos + radius;
      if(left >= 0 && kinds[left].kind === 'desc' && !usedDesc.has(left)){ usedDesc.add(left); return kinds[left].s; }
      if(right <  N && kinds[right].kind === 'desc' && !usedDesc.has(right)){ usedDesc.add(right); return kinds[right].s; }
    }
    return "";
  }

  // --- 次に「通常の数値行」 ---
  for(const r of kinds){
    if(r.kind !== 'num') continue;
    // すでに同じ No がラベル付きで出てたらスキップ（被り防止）
    const exist = items.find(it => it.idx === Number(r.s.match(numLine)[1]));
    if(exist) continue;

    const m = r.s.match(numLine);
    const idx = Number(m[1]);
    const { qty, qUnit } = parseQtyToken(m[2]);

    // 金額は行末寄りの2値優先
    const { unit, amount } = pickPricesFromLine(r.s);

    const desc = findNearestDesc(r.i);
    const [name, model] = splitNameModel(desc);
    items.push({ idx, name, model, qty, qUnit, unit, amount: amount || qty*unit });
  }

  // --- さらに「金額+説明」一体行 ---
  for(const r of kinds){
    if(r.kind !== 'lump') continue;
    const m = r.s.match(lump);
    const idx = Number(m[1]);
    // すでに同じ No が出てたらスキップ
    if(items.find(it => it.idx === idx)) continue;

    const amt = toInt(m[2]);
    const desc = normLine(m[3] || "");
    if(!desc) continue;
    const [name, model] = splitNameModel(desc);
    items.push({ idx, name, model, qty:1, qUnit:"式", unit:amt, amount:amt });
  }

  // No 昇順で返す
  items.sort((a,b)=> a.idx - b.idx);
  return items;
}
