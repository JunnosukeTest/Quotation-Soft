function parseItems(lines){
  // 正規化して配列に格納（行番号も持つ）
  const rows = lines.map((raw, i) => {
    const s = normLine(raw || "");
    return { i, s };
  });

  // パターン
  const numLine = /^(\d+)\s+(\d+(?:\s*(?:式|個|台))?)\b.*$/; // 数値行（No 数量 ...）
  // 金額と説明の間に空白が無くてもOKにする（例: "9 5,000梱包・運搬費"）
  const lump = /^(\d+)\s*([¥￥]?\s*\d{1,3}(?:,\d{3})*(?:\.\d+)?)(.*)$/;
  const skip = /^(合\s*計|項目|品名|御\s*見\s*積|納\s*期|有\s*効|支\s*払)/;

  // 行の種類を仕分け
  const kinds = rows.map(r => {
    if (numLine.test(r.s)) return { ...r, kind: 'num' };
    if (lump.test(r.s))   return { ...r, kind: 'lump' };
    if (skip.test(r.s))   return { ...r, kind: 'skip' };
    return { ...r, kind: 'desc' }; // 説明候補
  });

  // すでに使った説明行は再利用しない
  const usedDesc = new Set();

  // 近傍探索：ある行 idx の前後に半径を広げていき、最初に見つかった desc を返す
  function findNearestDesc(pos){
    const N = kinds.length;
    for (let radius = 1; radius <= 8; radius++){
      const left  = pos - radius;
      const right = pos + radius;
      if (left >= 0 && kinds[left].kind === 'desc' && !usedDesc.has(left)) { usedDesc.add(left); return kinds[left].s; }
      if (right <  N && kinds[right].kind === 'desc' && !usedDesc.has(right)) { usedDesc.add(right); return kinds[right].s; }
    }
    return ""; // 見つからなければ空
  }

  const items = [];

  // 1) 通常の数値行（No, 数量, 単価/金額は行内から抽出）
  for (const r of kinds){
    if (r.kind !== 'num') continue;
    const m = r.s.match(numLine);
    const idx = Number(m[1]);

    // 数量トークンをパース（全角OK、"3台"/"3 台"など）
    const { qty, qUnit } = parseQtyToken(m[2]);

    // 金額は「行の右側の数値2つ」を優先抽出
    const { unit, amount } = pickPricesFromLine(r.s);

    // 前後どちらにも説明がある可能性 → 近い方を採用
    const desc = findNearestDesc(r.i);
    const [name, model] = splitNameModel(desc);
    const amt = amount || (qty * unit);

    items.push({ idx, name, model, qty, qUnit, unit, amount: amt });
  }

  // 2) 例外形式（No 金額 説明）※金額と説明が隣接でもOK
  for (const r of kinds){
    if (r.kind !== 'lump') continue;
    const m = r.s.match(lump);
    const idx = Number(m[1]);
    const amt = toInt(m[2]); // "¥ 5,000" などOK
    // m[3] は前に空白が無い可能性があるのでトリム
    const desc = normLine(m[3] || "");
    if (!desc) continue; // 説明が無い場合はスキップ
    const [name, model] = splitNameModel(desc);
    items.push({ idx, name, model, qty: 1, qUnit: "式", unit: amt, amount: amt });
  }

  // No の昇順で並べて返す
  items.sort((a,b) => a.idx - b.idx);
  return items;
}
