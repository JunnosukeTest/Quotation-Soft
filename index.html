<!doctype html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>価格表示ツール（SP版・単一HTML）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 簡易スタイル（依存なし） -->
    <style>
      :root {
        --emerald-50: #ecfdf5;
        --emerald-200: #a7f3d0;
        --emerald-700: #047857;
        --emerald-800: #065f46;
        --orange-50: #fff7ed;
        --red-200: #fecaca;
        --red-700: #b91c1c;
        --gray-200: #e5e7eb;
        --gray-400: #9ca3af;
      }
      body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji"; background:#fff; color:#111; }
      .container { max-width: 960px; margin: 0 auto; padding: 24px; }
      h1 { color: var(--emerald-800); }
      section, .card { border: 1px solid var(--emerald-200); border-radius: 12px; padding: 16px; margin-bottom: 16px; background: #fff; }
      .title { margin: 0 0 8px; color: var(--emerald-800); }
      .row { display:flex; gap:8px; align-items:center; }
      .row-right { margin-left:auto; }
      .btn { padding: 6px 10px; border-radius: 6px; cursor:pointer; }
      .btn-primary { background:#059669; color:#fff; border:none; }
      .btn-ghost { background:#fff; color:var(--emerald-700); border:1px solid var(--emerald-200); }
      .btn-danger { background:#fff; color:var(--red-700); border:1px solid var(--red-200); }
      .drop { border:2px dashed var(--emerald-200); border-radius:16px; padding:16px; text-align:center; cursor:pointer; background:#fff; }
      .hint { color: var(--emerald-700); font-size:12px; }
      table { width:100%; border-collapse:collapse; }
      thead { background: var(--emerald-50); color: var(--emerald-800); }
      th, td { text-align:left; padding: 6px 8px; border-bottom: 1px solid var(--gray-200); vertical-align: top; }
      .muted { color: var(--gray-400); }
      .warn-row { background: var(--orange-50); }
      input[type="text"] { width:100%; padding:6px; border:1px solid #d1d5db; border-radius:6px; }
      .copy { margin-left:8px; border:1px solid var(--emerald-200); color:var(--emerald-700); background: var(--emerald-50); padding:4px 8px; border-radius:6px; }
      .toast { position: fixed; top: 16px; right: 16px; background: #111; color:#fff; padding:10px 12px; border-radius:8px; opacity:0.96; z-index:9999; }
    </style>

    <!-- React / ReactDOM / Babel（CDN: ビルド不要で JSX が動く） -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js" crossorigin></script>

    <!-- Papa Parse（CSV） -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- PDF.js（本体 & ワーカーはCDNに設定） -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script>
      // PDF.js の worker を CDN に向ける（bundler 不要で確実に動作）
      pdfjsLib.GlobalWorkerOptions.workerSrc =
        "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js";
    </script>
  </head>

  <body>
    <div class="container">
      <div id="root"></div>
    </div>

    <!-- アプリ本体（Babelで JSX を変換） -->
    <script type="text/babel">
      const { useCallback, useMemo, useRef, useState } = React;

      // ---- 小さなトースト（依存なし） ----
      function toast(msg) {
        const el = document.createElement('div');
        el.className = 'toast';
        el.textContent = msg;
        document.body.appendChild(el);
        setTimeout(() => { el.remove(); }, 1800);
      }

      // ---- Helpers ----
      const jpYen = (n) => {
        const num = parseFloat(String(n ?? "").toString().replace(/[^0-9.-]/g, ""));
        if (isNaN(num)) return "";
        return new Intl.NumberFormat("ja-JP").format(num); // 単位は付けない
      };
      const stripParen = (s) => String(s ?? "").replace(/\([^)]*\)/g, "").trim();
      const isNoise = (s) =>
        /^(TNHS-|TEL|FAX|PC|UL|COM)/i.test(String(s).trim()) || /^DSP3000$/i.test(String(s).trim());
      const isValidModel = (s) => {
        const base = stripParen(s);
        if (!/^[A-Z]/.test(base)) return false;
        if (/[ァ-ヶー]/.test(base) || /[ｦ-ﾟ]/.test(base)) return false;
        return true;
      };
      const normalizeKey = (s) => stripParen(s).toUpperCase().replace(/[-\s]/g, "");
      const parseModelList = (text) => {
        if (!text) return [];
        return text
          .split(/[\n,;\t\s]+/)
          .map((x) => stripParen(x))
          .map((x) => x.trim())
          .filter((x) => Boolean(x) && !isNoise(x) && isValidModel(x));
      };

      async function safeCopy(text) {
        const val = String(text ?? "");
        try {
          if (navigator.clipboard && window.isSecureContext) {
            await navigator.clipboard.writeText(val);
            return true;
          }
        } catch {}
        try {
          const ta = document.createElement("textarea");
          ta.value = val;
          ta.setAttribute("readonly", "");
          ta.style.position = "fixed";
          ta.style.top = "-1000px";
          ta.style.left = "-1000px";
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          ta.setSelectionRange(0, ta.value.length);
          const ok = document.execCommand && document.execCommand("copy");
          document.body.removeChild(ta);
          return !!ok;
        } catch {
          return false;
        }
      }

      function useSpCsvMap() {
        const [map, setMap] = useState(null);
        const [meta, setMeta] = useState(null);

        const load = useCallback(async (file) => {
          return new Promise((resolve, reject) => {
            Papa.parse(file, {
              header: false,
              skipEmptyLines: true,
              complete: (res) => {
                const rows = res.data;
                const m = new Map();
                let kept = 0;

                for (const row of rows) {
                  const rawModel = row?.[0];
                  const listPrice = row?.[1] ?? "";
                  const cost = row?.[2] ?? "";
                  if (!rawModel) continue;

                  const model = stripParen(rawModel);
                  if (isNoise(model) || !isValidModel(model)) continue;

                  const key = normalizeKey(model);
                  const entry = m.get(key) || { model: String(model).trim(), variants: [] };

                  const sig = String(listPrice) + "|||" + String(cost);
                  const hasSame = entry.variants.some((v) => (String(v.listPrice) + "|||" + String(v.cost)) === sig);
                  if (!hasSame && entry.variants.length < 2) {
                    entry.variants.push({ listPrice, cost });
                  }
                  m.set(key, entry);
                  kept++;
                }

                setMap(m);
                setMeta({ rows: rows.length, kept, uniqueKeys: m.size, fileName: file.name });
                resolve(m);
              },
              error: (err) => reject(err),
              encoding: "UTF-8",
            });
          });
        }, []);

        return { map, meta, load };
      }

      async function extractTextFromPdf(file) {
        const buf = await file.arrayBuffer();
        const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
        let text = "";
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i);
          const content = await page.getTextContent();
          text += content.items.map((it) => (it.str ? it.str + "\n" : "")).join("");
        }
        return text.trim();
      }

      function CopyBtn({ value }) {
        const onClick = useCallback(async () => {
          const ok = await safeCopy(value);
          toast(ok ? "コピーしました" : "コピーできませんでした（ブラウザの制限）");
        }, [value]);
        return <button type="button" onClick={onClick} className="copy">コピー</button>;
      }

      function DropZone({ onFiles, accept="*", label="ここにファイルをドロップ / クリックで選択" }) {
        const inputRef = useRef(null);
        const onDrop = useCallback((e) => {
          e.preventDefault();
          const files = e.dataTransfer.files;
          if (files && files.length) onFiles(Array.from(files));
        }, [onFiles]);
        return (
          <div className="drop" onDragOver={(e)=>e.preventDefault()} onDrop={onDrop} onClick={()=>inputRef.current?.click()}>
            <p className="hint">{label}</p>
            <input ref={inputRef} type="file" accept={accept} style={{display:"none"}} onChange={(e)=>onFiles(Array.from(e.target.files||[]))}/>
          </div>
        );
      }

      function genId(prefix="ROW") {
        return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2,8)}`;
      }

      function App() {
        const { map: spMap, meta: spMeta, load: loadSp } = useSpCsvMap();
        const [pdfText, setPdfText] = useState("");
        const [loadingPdf, setLoadingPdf] = useState(false);
        const [rows, setRows] = useState([]);
        const [inplaceEdit, setInplaceEdit] = useState(false);

        // ---- Priority helpers ----
        const buildRowsFromModels = useCallback((modelList) => {
          return modelList.flatMap((m, occIdx) => {
            const key = normalizeKey(m);
            const hit = spMap ? spMap.get(key) : null;
            const variants = hit?.variants?.length ? hit.variants.slice(0, 2) : [{ listPrice: "", cost: "" }];
            return variants.map((v, i) => ({
              id: `${key}-${occIdx}-${i}`,
              model: hit?.model || stripParen(m),
              listPrice: v.listPrice,
              cost: v.cost,
              found: Boolean(hit),
              note: hit ? "一致（SP）" : "未一致",
              show: true,
            }));
          });
        }, [spMap]);

        const resolvePricesFromCsv = useCallback((prevRows) => {
          if (!spMap) return prevRows;
          return prevRows.map((r) => {
            const key = normalizeKey(r.model || "");
            const hit = key ? spMap.get(key) : null;
            if (hit?.variants?.length) {
              const v = hit.variants[0];
              return { ...r, listPrice: v.listPrice, cost: v.cost, found: true, note: "一致（SP）" };
            }
            return { ...r, found: false, note: "未一致" };
          });
        }, [spMap]);

        const handleLoadSpCsv = useCallback(async (files) => {
          if (!files?.length) return;
          const file = files[0];
          if (!file.name.toLowerCase().endsWith(".csv")) return toast("CSVファイルを選択してください");
          try {
            await loadSp(file);
            toast("SP 価格マスタを読み込みました");
            setRows((prev) => resolvePricesFromCsv(prev)); // 1優先
          } catch (e) {
            console.error(e);
            toast("CSVの読み込みに失敗しました");
          }
        }, [loadSp, resolvePricesFromCsv]);

        const handlePdfDrop = useCallback(async (files) => {
          if (!files?.length) return;
          const file = files[0];
          if (!(file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf")))
            return toast("PDFファイルを選択してください");
          setLoadingPdf(true);
          try {
            const text = await extractTextFromPdf(file);
            if (!text) toast("画像ベースのため表示エラー（テキスト抽出不可）");
            setPdfText(text || "");
            if (text) {
              const nextModels = parseModelList(text);
              const nextRows = buildRowsFromModels(nextModels); // 2 → 3
              setRows(nextRows);
              setInplaceEdit(true);
              toast("PDFを優先して見積表を更新しました（2→3）");
            }
          } catch (e) {
            console.error(e);
            toast("PDF抽出に失敗しました");
          } finally {
            setLoadingPdf(false);
          }
        }, [buildRowsFromModels]);

        const models = useMemo(() => parseModelList(pdfText), [pdfText]);

        const addRow = useCallback(() => {
          setRows((prev)=>[...prev, { id: genId(), model:"", listPrice:"", cost:"", found:false, note:"手入力", show:true }]);
        }, []);
        const deleteRow = useCallback((id)=> setRows((prev)=>prev.filter((r)=>r.id!==id)), []);

        const handleEstimate = useCallback(() => {
          if (inplaceEdit) {
            if (!spMap) { toast("SPマスタ未読込のため反映スキップ"); setInplaceEdit(false); return; }
            setRows((prev)=>resolvePricesFromCsv(prev)); // 3 で 1 を反映
            setInplaceEdit(false);
            toast("編集を確定し、CSVに基づく価格を反映しました（1優先）");
            return;
          }
          if (rows.length > 0) { setInplaceEdit(true); toast("直接編集モードに切替"); return; }
          if (!spMap) { toast("SP マスタ未読込です"); return; }
          if (!models.length) { toast("PDFから型式を抽出してください"); return; }
          const expanded = buildRowsFromModels(models);
          setRows(expanded);
          setInplaceEdit(true);
          toast("PDF結果を読み込み、直接編集モードに切替");
        }, [inplaceEdit, rows.length, spMap, models, buildRowsFromModels, resolvePricesFromCsv]);

        const updateRow = useCallback((id, key, val) => {
          setRows((prev)=> prev.map((r)=> r.id===id ? { ...r, [key]: val } : r));
        }, []);

        return (
          <>
            <header style={{ marginBottom: 24, display:"flex", justifyContent:"space-between", alignItems:"center" }}>
              <h1 className="title">価格表示ツール（SP版）</h1>
              <div className="hint">背景：白 / 基調：ライトグリーン</div>
            </header>

            <section>
              <h2 className="title">1. SP価格マスタCSVの読み込み</h2>
              <DropZone accept=".csv" onFiles={handleLoadSpCsv} label={"SP.csv をドロップ / クリックで選択（A=型式, B=定価, C=仕入）"} />
              {spMeta && (
                <div className="hint" style={{ marginTop: 8 }}>
                  {spMeta.fileName} / 有効行: {spMeta.kept} / 一意型式: {spMeta.uniqueKeys}件
                </div>
              )}
            </section>

            <section>
              <h2 className="title">2. 型式の入力（PDF抽出）</h2>
              <DropZone accept="application/pdf,.pdf" onFiles={handlePdfDrop} label="PDFをドロップ / クリックで選択（画像ベースはエラー表示）" />
              <div className="hint" style={{ marginTop:8 }}>
                {loadingPdf ? "抽出中..." : pdfText ? `${pdfText.slice(0,80)}...` : ""}
              </div>
            </section>

            <section>
              <h2 className="title">3. 価格表の表示（SP／重複は上下2段表示）</h2>
              <div className="row" style={{ marginBottom: 12 }}>
                {inplaceEdit && (
                  <button className="btn btn-ghost" onClick={addRow}>行を追加</button>
                )}
                <div className="row-right"></div>
                <button className="btn btn-primary" onClick={handleEstimate}>
                  {inplaceEdit ? "決定（見積表示）" : rows.length > 0 ? "再編集（見積表示）" : "見積表示"}
                </button>
              </div>

              <div style={{ overflow:"auto", border:"1px solid var(--emerald-200)", borderRadius:12 }}>
                <table>
                  <thead>
                    <tr>
                      <th>項目</th>
                      <th>型式</th>
                      <th>定価</th>
                      <th>仕入</th>
                      <th>備考</th>
                      <th>操作</th>
                    </tr>
                  </thead>
                  <tbody>
                    {rows.length === 0 ? (
                      <tr><td colSpan="6" className="hint" style={{ textAlign:"center", padding:16 }}>ここに結果が表示されます</td></tr>
                    ) : rows.map((r, idx) => (
                      <tr key={r.id} className={r.found ? "" : "warn-row"}>
                        <td style={{ fontSize:12 }}>{idx + 1}</td>
                        <td style={{ whiteSpace:"nowrap" }}>
                          {inplaceEdit ? (
                            <input type="text" value={r.model} onChange={(e)=>updateRow(r.id,"model",e.target.value)} />
                          ) : (
                            <span style={{ fontWeight:600, color:"var(--emerald-800)" }}>{r.model}</span>
                          )}
                          {!inplaceEdit && <CopyBtn value={r.model} />}
                        </td>
                        <td>
                          {inplaceEdit ? (
                            <input type="text" value={r.listPrice} onChange={(e)=>updateRow(r.id,"listPrice",e.target.value)} placeholder="定価" />
                          ) : r.listPrice ? (
                            <span>{jpYen(r.listPrice)}</span>
                          ) : <span className="muted">—</span>}
                          {!inplaceEdit && r.listPrice && <CopyBtn value={jpYen(r.listPrice)} />}
                        </td>
                        <td>
                          {inplaceEdit ? (
                            <input type="text" value={r.cost} onChange={(e)=>updateRow(r.id,"cost",e.target.value)} placeholder="仕入" />
                          ) : r.cost ? (
                            <span>{jpYen(r.cost)}</span>
                          ) : <span className="muted">—</span>}
                          {!inplaceEdit && r.cost && <CopyBtn value={jpYen(r.cost)} />}
                        </td>
                        <td style={{ fontSize:12 }}>
                          {r.note ? <span style={{ color:"var(--emerald-700)" }}>{r.note}</span> : r.found ? <span style={{ color:"var(--emerald-700)" }}>一致（SP）</span> : <span style={{ color:"#9A3412" }}>未一致</span>}
                        </td>
                        <td style={{ fontSize:12 }}>
                          <button className="btn btn-danger" onClick={()=>deleteRow(r.id)}>削除</button>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </section>

            <footer className="hint" style={{ marginTop:24 }}>
              <ul>
                <li>CSVは <b>A=型式, B=定価, C=仕入</b>。同一型式で異なる金額がある場合は<b>最大2種類</b>を保持・表示します。</li>
                <li><b>TNHS-</b> / <b>TEL</b> / <b>FAX</b> / <b>DSP3000</b> / <b>PC</b> / <b>UL</b> / <b>COM</b> 始まりは自動で無視します。</li>
                <li>型式末尾の <b>( ... )</b> は無視して照合します（例：ABC-123 (50Hz) → ABC-123）。</li>
                <li>PDFはテキストベースのみ対応（画像ベースPDFは抽出不可）。</li>
              </ul>
            </footer>
          </>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
