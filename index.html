"use client";
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import Papa from "papaparse";
import * as pdfjsLib from "pdfjs-dist";
import "pdfjs-dist/build/pdf.worker.mjs";

// ----------------------------------
// Helpers
// ----------------------------------
const jpYen = (n: any) => {
  const num = parseFloat(String(n ?? "").toString().replace(/[^0-9.-]/g, ""));
  if (isNaN(num)) return "";
  return new Intl.NumberFormat("ja-JP").format(num);
};

// ()内注記を無視
const stripParen = (s: any) => String(s ?? "").replace(/\([^)]*\)/g, "").trim();

// ノイズ: 見積番号/連絡先/型式ではないコードなど
const isNoise = (s: any) => /^(TNHS-|TEL|FAX|PC|UL|COM)/i.test(String(s).trim()) || /^DSP3000$/i.test(String(s).trim());

// 型式: 先頭英大文字、日本語（ひらがな・カタカナ（全/半）・漢字）を含まない
const isValidModel = (s: any) => {
  const base = stripParen(s);
  if (!/^[A-Z]/.test(base)) return false; // 先頭は英大文字
  if (/[ぁ-んァ-ヶーｦ-ﾟ一-龯々]/.test(base)) return false; // 日本語文字は対象外
  return true;
};

// キー正規化: 大文字化・ハイフン/空白除去・()内削除
const normalizeKey = (s: any) => stripParen(s).toUpperCase().replace(/[-\s]/g, "");

// PDFからの型式抽出（重複は保持）
const parseModelList = (text: string) => {
  if (!text) return [] as string[];
  return text
    .split(/[\n,;\t\s]+/)
    .map((x) => stripParen(x))
    .map((x) => String(x).trim())
    .filter((x) => Boolean(x) && !isNoise(x) && isValidModel(x));
};

// クリップボード（まず Clipboard API、失敗時はフォールバックUI）
async function tryWriteClipboard(text: string) {
  try {
    if (typeof navigator !== "undefined" && (navigator as any).clipboard && typeof window !== "undefined" && (window as any).isSecureContext) {
      await (navigator as any).clipboard.writeText(text);
      return true;
    }
  } catch {}
  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.top = "-1000px";
    ta.style.left = "-1000px";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    ta.setSelectionRange(0, ta.value.length);
    const ok = document.execCommand && document.execCommand("copy");
    document.body.removeChild(ta);
    if (ok) return true;
  } catch {}
  return false;
}

// ----------------------------------
// CSV 読込（SP/NR/HNR 1ファイル対応: 縦持ち/横持ち）
// ----------------------------------
// 内部構造: Map<key, { model: string, variantsByType: { SP: Variant[]; NR: Variant[]; HNR: Variant[] } }>
// 旧フォーマット（variantsのみ）も互換維持

type Variant = { listPrice: string; cost: string };
type Entry = { model: string; variantsByType?: Record<"SP" | "NR" | "HNR", Variant[]>; variants?: Variant[] };

function useSpCsvMap() {
  const [map, setMap] = useState<Map<string, Entry> | null>(null);
  const [meta, setMeta] = useState<any>(null);

  const load = useCallback(async (file: File) => {
    return new Promise<Map<string, Entry>>((resolve, reject) => {
      Papa.parse(file, {
        header: false,
        skipEmptyLines: true,
        complete: (res: any) => {
          const rows: any[][] = res.data;
          const m = new Map<string, Entry>();
          let kept = 0;
          const byTypeCount = { SP: 0, NR: 0, HNR: 0 } as Record<string, number>;

          const ensureEntry = (key: string, model: string) => {
            const cur = m.get(key);
            if (cur) return cur;
            const entry: Entry = { model: String(model).trim(), variantsByType: { SP: [], NR: [], HNR: [] } };
            m.set(key, entry);
            return entry;
          };

          const isHeaderRow = (cells: any[]) => {
            const c0 = String(cells?.[0] ?? "").toUpperCase();
            return ["MODEL", "品番", "型式"].some((h) => c0.includes(h));
          };

          for (const row of rows) {
            if (!row || row.length === 0) continue;
            if (isHeaderRow(row)) continue;

            const rawModel = row?.[0];
            if (!rawModel) continue;
            const model = stripParen(rawModel);
            if (isNoise(model) || !isValidModel(model)) continue;
            const key = normalizeKey(model);

            // 縦持ち: MODEL, LIST, COST, TYPE
            // 横持ち: MODEL, SP_LIST, SP_COST, NR_LIST, NR_COST, HNR_LIST, HNR_COST
            const hasTypeCol = row.length >= 4 && String(row[3] || "").trim() !== "";
            const looksWide = row.length >= 6 && (String(row[1] || "") !== "" || String(row[3] || "") !== "" || String(row[5] || "") !== "");

            if (hasTypeCol && !looksWide) {
              const listPrice = row?.[1] ?? "";
              const cost = row?.[2] ?? "";
              let type = String(row?.[3] ?? "SP").toUpperCase().replace(/[^A-Z]/g, "");
              if (!["SP", "NR", "HNR"].includes(type)) type = "SP";
              const entry = ensureEntry(key, model);
              const arr = (entry.variantsByType as any)[type] as Variant[];
              const sig = String(listPrice) + "|||" + String(cost);
              const hasSame = arr.some((v) => String(v.listPrice) + "|||" + String(v.cost) === sig);
              if (!hasSame && arr.length < 2) {
                arr.push({ listPrice, cost });
                kept++;
                byTypeCount[type]++;
              }
            } else {
              const entry = ensureEntry(key, model);
              const pushIf = (type: "SP" | "NR" | "HNR", lp: any, cs: any) => {
                const listPrice = lp ?? "";
                const cost = cs ?? "";
                if (listPrice === "" && cost === "") return;
                const arr = (entry.variantsByType as any)[type] as Variant[];
                const sig = String(listPrice) + "|||" + String(cost);
                const hasSame = arr.some((v) => String(v.listPrice) + "|||" + String(v.cost) === sig);
                if (!hasSame && arr.length < 2) {
                  arr.push({ listPrice, cost });
                  kept++;
                  byTypeCount[type]++;
                }
              };
              pushIf("SP", row?.[1], row?.[2]);
              pushIf("NR", row?.[3], row?.[4]);
              pushIf("HNR", row?.[5], row?.[6]);
            }
          }

          setMap(m);
          setMeta({ rows: rows.length, kept, uniqueKeys: m.size, fileName: file.name, byTypeCount });
          resolve(m);
        },
        error: (err: any) => reject(err),
        encoding: "UTF-8",
      });
    });
  }, []);

  return { map, meta, load };
}

// ----------------------------------
// PDF テキスト抽出（プレビューなし）
// ----------------------------------
async function extractTextFromPdf(file: File) {
  const buf = await file.arrayBuffer();
  const pdf = await (pdfjsLib as any).getDocument({ data: buf }).promise;
  let text = "";
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += content.items.map((it: any) => (it.str ? it.str + "\n" : "")).join("");
  }
  return text.trim();
}

// ----------------------------------
// UI: DropZone / CopyDialog / Toast
// ----------------------------------
function DropZone({ onFiles, accept = "*", label = "ここにファイルをドロップ / クリックで選択" }: { onFiles: (files: File[]) => void; accept?: string; label?: string }) {
  const inputRef = useRef<HTMLInputElement | null>(null);
  const onDrop = useCallback(
    (e: React.DragEvent<HTMLDivElement>) => {
      e.preventDefault();
      const files = (e.dataTransfer as DataTransfer).files;
      if (files && files.length) onFiles(Array.from(files));
    },
    [onFiles]
  );
  return (
    <div
      onDragOver={(e) => e.preventDefault()}
      onDrop={onDrop}
      onClick={() => inputRef.current?.click()}
      style={{ border: "2px dashed #6ee7b7", borderRadius: 16, padding: 24, textAlign: "center", cursor: "pointer", background: "#fff" }}
    >
      <p style={{ fontSize: 12, color: "#047857" }}>{label}</p>
      <input ref={inputRef} type="file" accept={accept} style={{ display: "none" }} onChange={(e) => onFiles(Array.from(e.target.files || ([] as any)))} />
    </div>
  );
}

function CopyDialog({ open, title, text, onClose }: { open: boolean; title: string; text: string; onClose: () => void }) {
  const taRef = useRef<HTMLTextAreaElement | null>(null);
  useEffect(() => {
    if (open && taRef.current) {
      taRef.current.focus();
      taRef.current.select();
    }
  }, [open]);
  if (!open) return null;
  return (
    <div style={{ position: "fixed", inset: 0, display: "flex", alignItems: "center", justifyContent: "center", background: "rgba(0,0,0,.3)", padding: 16, zIndex: 50 }}>
      <div style={{ width: "min(720px,95vw)", background: "#fff", border: "1px solid #e5e7eb", borderRadius: 14, overflow: "hidden", boxShadow: "0 10px 30px rgba(0,0,0,.25)" }}>
        <div style={{ display: "flex", alignItems: "center", justifyContent: "space-between", padding: "10px 14px", borderBottom: "1px solid #e5e7eb" }}>
          <div style={{ fontWeight: 600, color: "#064e3b" }}>{title}</div>
          <button onClick={onClose} style={{ padding: "6px 10px", borderRadius: 8, border: "1px solid #a7f3d0", background: "#fff", color: "#047857", fontWeight: 600 }}>閉じる</button>
        </div>
        <div style={{ padding: 12 }}>
          <p style={{ fontSize: 12, color: "#065f46", margin: "0 0 8px" }}>全選択済みです。Ctrl/Cmd+C でコピーし、Excelの結合セル先頭に貼り付けてください。</p>
          <textarea ref={taRef} style={{ width: "100%", height: 320, padding: 10, border: "1px solid #e5e7eb", borderRadius: 8, fontFamily: "ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace", fontSize: 13 }} defaultValue={text} readOnly />
        </div>
      </div>
    </div>
  );
}

function useToast() {
  const [msg, setMsg] = useState<string | null>(null);
  const [kind, setKind] = useState<"normal" | "error">("normal");
  useEffect(() => {
    if (!msg) return;
    const t = setTimeout(() => setMsg(null), 1800);
    return () => clearTimeout(t);
  }, [msg]);
  const Toast = () => (
    <div
      style={{
        position: "fixed",
        right: 16,
        bottom: 16,
        background: kind === "error" ? "#9f1239" : "#111827",
        color: "#fff",
        padding: "10px 14px",
        borderRadius: 10,
        boxShadow: "0 10px 15px rgba(0,0,0,.2)",
        opacity: msg ? 1 : 0,
        transform: `translateY(${msg ? 0 : 8}px)`,
        transition: "all .2s",
        pointerEvents: "none",
        zIndex: 60,
      }}
    >
      {msg}
    </div>
  );
  return {
    toast: (m: string, k: "normal" | "error" = "normal") => {
      setKind(k);
      setMsg(m);
    },
    Toast,
  };
}

// ----------------------------------
// Main
// ----------------------------------
export default function App() {
  const { map: spMap, meta: spMeta, load: loadSp } = useSpCsvMap();
  const { toast, Toast } = useToast();

  const [pdfText, setPdfText] = useState("");
  const [loadingPdf, setLoadingPdf] = useState(false);
  const [rows, setRows] = useState<any[]>([]);
  const [inplaceEdit, setInplaceEdit] = useState(false);
  const [copyUI, setCopyUI] = useState<{ open: boolean; title: string; text: string }>({ open: false, title: "", text: "" });

  // buildRowsFromModels: PDFの型式リスト→表示行を生成（CSVがあれば即価格も埋める）
  const buildRowsFromModels = useCallback(
    (modelList: string[]) => {
      const pickType = (entry: Entry | undefined | null) => {
        if (!entry) return { type: "SP" as const, arr: [] as Variant[] };
        if (entry.variantsByType) {
          for (const t of ["SP", "NR", "HNR"] as const) {
            const arr = entry.variantsByType[t];
            if (arr && arr.length) return { type: t, arr };
          }
          return { type: "SP" as const, arr: [] as Variant[] };
        }
        return { type: "SP" as const, arr: entry.variants || [] };
      };

      return modelList.flatMap((m, occIdx) => {
        const key = normalizeKey(m);
        const hit = spMap ? spMap.get(key) : null;
        const picked = pickType(hit || undefined);
        const variants = picked.arr.length ? picked.arr.slice(0, 2) : [{ listPrice: "", cost: "" }];
        return variants.map((v, i) => ({
          id: `${key}-${occIdx}-${i}`,
          model: (hit?.model ?? stripParen(m)) as string,
          listPrice: v.listPrice,
          cost: v.cost,
          found: Boolean(hit) && picked.arr.length > 0,
          note: hit && picked.arr.length > 0 ? `一致（${picked.type})` : "未一致",
          variantIndex: i,
          selectedType: picked.type,
        }));
      });
    },
    [spMap]
  );

  // CSV -> 既存行の価格を再計算（型式は保持 / 選択タイプを優先）
  const resolvePricesFromCsv = useCallback(
    (prevRows: any[]) => {
      if (!spMap) return prevRows;

      const pickType = (entry: Entry | undefined | null) => {
        if (!entry) return { type: "SP" as const, arr: [] as Variant[] };
        if (entry.variantsByType) {
          for (const t of ["SP", "NR", "HNR"] as const) {
            const arr = entry.variantsByType[t];
            if (arr && arr.length) return { type: t, arr };
          }
          return { type: "SP" as const, arr: [] as Variant[] };
        }
        return { type: "SP" as const, arr: entry.variants || [] };
      };

      return prevRows.map((r) => {
        const key = normalizeKey(r.model || "");
        const hit = key ? spMap.get(key) : null;
        let type = r.selectedType as "SP" | "NR" | "HNR" | undefined;
        let arr: Variant[] = [];

        if (hit?.variantsByType) {
          arr = type ? (hit.variantsByType[type] || []) : [];
          if (!arr.length) {
            const picked = pickType(hit);
            type = picked.type;
            arr = picked.arr;
          }
        } else {
          const picked = pickType(hit || undefined);
          type = picked.type;
          arr = picked.arr;
        }

        if (arr.length) {
          const vi = Number.isInteger(r?.variantIndex) ? r.variantIndex : 0;
          const v = arr[vi] || arr[0];
          return { ...r, listPrice: v.listPrice, cost: v.cost, found: true, note: `一致（${type})`, selectedType: type };
        }
        return { ...r, found: false, note: "未一致", selectedType: type || r.selectedType };
      });
    },
    [spMap]
  );

  // 1. CSV 読込
  const handleLoadSpCsv = useCallback(
    async (files: File[]) => {
      if (!files?.length) return;
      const file = files[0];
      if (!file.name.toLowerCase().endsWith(".csv")) return toast("CSVファイルを選択してください", "error");
      try {
        await loadSp(file);
        toast("価格マスタを読み込みました");
        setRows((prev) => resolvePricesFromCsv(prev));
      } catch (e) {
        console.error(e);
        toast("CSVの読み込みに失敗しました", "error");
      }
    },
    [loadSp, resolvePricesFromCsv, toast]
  );

  // 2. PDF投入
  const handlePdfDrop = useCallback(
    async (files: File[]) => {
      if (!files?.length) return;
      const file = files[0];
      if (!(file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf"))) return toast("PDFファイルを選択してください", "error");
      setLoadingPdf(true);
      try {
        const text = await extractTextFromPdf(file);
        if (!text) toast("画像ベースのため表示エラー", "error");
        setPdfText(text || "");
        if (text) {
          const nextModels = parseModelList(text);
          const nextRows = buildRowsFromModels(nextModels);
          setRows(nextRows);
          setInplaceEdit(true);
          toast("PDFを優先して見積表を更新しました（2→3）");
        }
      } catch (e) {
        console.error(e);
        toast("PDF抽出に失敗しました", "error");
      } finally {
        setLoadingPdf(false);
      }
    },
    [buildRowsFromModels, toast]
  );

  // 行追加/削除/編集確定
  const addRow = useCallback(() => {
    setRows((prev) => [
      ...prev,
      { id: `ROW-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`, model: "", listPrice: "", cost: "", found: false, note: "手入力", variantIndex: 0, selectedType: undefined },
    ]);
  }, []);

  const deleteRow = useCallback((id: string) => {
    setRows((prev) => prev.filter((r) => r.id !== id));
  }, []);

  const handleEstimate = useCallback(() => {
    if (inplaceEdit) {
      if (!spMap) {
        toast("マスタ未読込のため反映スキップ");
        setInplaceEdit(false);
        return;
      }
      setRows((prev) => resolvePricesFromCsv(prev));
      setInplaceEdit(false);
      toast("編集を確定し、CSVに基づく価格を反映しました");
      return;
    }

    if (rows.length > 0) {
      setInplaceEdit(true);
      toast("直接編集モードに切替");
      return;
    }

    if (!spMap) {
      toast("CSV マスタ未読込です", "error");
      return;
    }

    if (!pdfText) {
      toast("PDFから型式を抽出してください", "error");
      return;
    }

    const expanded = buildRowsFromModels(parseModelList(pdfText));
    setRows(expanded);
    setInplaceEdit(true);
    toast("PDF結果を読み込み、直接編集モードに切替");
  }, [inplaceEdit, rows.length, spMap, pdfText, buildRowsFromModels, resolvePricesFromCsv, toast]);

  const updateRow = useCallback((id: string, key: string, val: any) => {
    setRows((prev) =>
      prev.map((r) => {
        if (r.id !== id) return r;
        let nextVal = val;
        if (key === "listPrice" || key === "cost") {
          nextVal = String(val).replace(/^[^0-9-]+/, "");
        }
        return { ...r, [key]: nextVal };
      })
    );
  }, []);

  // 列コピー（結合セル配慮：1列分を改行で整形。Clipboard失敗時はダイアログ表示）
  const buildColumnText = useCallback(
    (ci: number) => {
      // 0:項目, 1:型式, 2:定価, 3:仕入, 4:備考, 5:操作
      const pick = (r: any) => {
        if (ci === 1) return String(r.model || "");
        if (ci === 2) return r.listPrice ? jpYen(r.listPrice) : "";
        if (ci === 3) return r.cost ? jpYen(r.cost) : "";
        if (ci === 4) return String(r.note ?? "");
        return "";
      };
      return rows.map(pick).join("\r\n"); // CRLF
    },
    [rows]
  );

  const copyColumn = useCallback(
    async (ci: number) => {
      const label = ci === 1 ? "型式" : ci === 2 ? "定価" : ci === 3 ? "仕入" : "列";
      const text = buildColumnText(ci);
      if (!text) {
        toast(`${label} 列に有効な値がありません`);
        return;
      }
      try {
        const ok = await tryWriteClipboard(text);
        if (ok) {
          toast("コピーしました");
          return;
        }
        throw new Error("clipboard blocked");
      } catch {
        toast("クリップボードに直接コピーできませんでした（ブラウザの制限）", "error");
        setCopyUI({ open: true, title: `${label} 列のコピー用テキスト`, text });
      }
    },
    [buildColumnText, toast]
  );

  // ----------------------------------
  // Render
  // ----------------------------------
  return (
    <div style={{ minHeight: "100vh", background: "#fff" }}>
      <div style={{ maxWidth: 1080, margin: "0 auto", padding: 24 }}>
        <header style={{ display: "flex", alignItems: "center", justifyContent: "space-between", marginBottom: 24 }}>
          <h1 style={{ fontSize: 22, color: "#065f46", margin: 0, fontWeight: 700 }}>価格表示ツール（格子コピー対応・TSX版）</h1>
          <div style={{ fontSize: 12, color: "#047857" }}>背景：白 / 基調：ライトグリーン</div>
        </header>

        <section style={{ border: "1px solid #a7f3d0", borderRadius: 16, marginBottom: 24 }}>
          <div style={{ padding: "12px 16px", borderBottom: "1px solid #e5e7eb" }}>
            <h2 style={{ margin: 0, fontWeight: 600, color: "#065f46" }}>1. 価格マスタCSVの読み込み</h2>
          </div>
          <div style={{ padding: 16 }}>
            <DropZone accept=".csv" onFiles={handleLoadSpCsv} label={"master.csv をドロップ / クリックで選択（縦持ち or 横持ち: SP/NR/HNR 同梱可）"} />
            {spMeta && (
              <div style={{ fontSize: 12, color: "#047857", marginTop: 8 }}>
                {spMeta.fileName} / 有効行: {spMeta.kept} / 一意型式: {spMeta.uniqueKeys}件
              </div>
            )}
          </div>
        </section>

        <section style={{ border: "1px solid #a7f3d0", borderRadius: 16, marginBottom: 24 }}>
          <div style={{ padding: "12px 16px", borderBottom: "1px solid #e5e7eb" }}>
            <h2 style={{ margin: 0, fontWeight: 600, color: "#065f46" }}>2. 型式の入力（PDF抽出）</h2>
          </div>
          <div style={{ padding: 16 }}>
            <DropZone accept="application/pdf,.pdf" onFiles={handlePdfDrop} label="PDFをドロップ / クリックで選択" />
            <div style={{ fontSize: 12, color: "#047857", marginTop: 8 }}>{loadingPdf ? "抽出中..." : pdfText ? `${pdfText.slice(0, 80)}...` : ""}</div>
          </div>
        </section>

        <section style={{ border: "1px solid #a7f3d0", borderRadius: 16, marginBottom: 16 }}>
          <div style={{ padding: "12px 16px", borderBottom: "1px solid #e5e7eb" }}>
            <h2 style={{ margin: 0, fontWeight: 600, color: "#065f46" }}>3. 見積表（縦列コピーはヘッダの「コピー」ボタン）</h2>
          </div>
          <div style={{ padding: 16 }}>
            <div style={{ display: "flex", alignItems: "center", gap: 12, marginBottom: 12 }}>
              {inplaceEdit && (
                <button onClick={addRow} style={{ padding: "6px 10px", borderRadius: 8, border: "1px solid #a7f3d0", background: "#fff", color: "#047857", fontWeight: 600 }}>行を追加</button>
              )}
              <button onClick={handleEstimate} style={{ marginLeft: "auto", padding: "6px 10px", borderRadius: 8, background: "#059669", color: "#fff", border: "1px solid #059669", fontWeight: 700 }}>
                {inplaceEdit ? "決定（見積表示）" : rows.length > 0 ? "再編集（見積表示）" : "見積表示"}
              </button>
            </div>

            <div style={{ overflow: "auto", border: "1px solid #a7f3d0", borderRadius: 12 }}>
              <table style={{ width: "100%", borderCollapse: "collapse", tableLayout: "fixed", fontSize: 14 }}>
                <thead style={{ background: "#ecfdf5", color: "#065f46" }}>
                  <tr>
                    {["項目", "型式", "定価", "仕入", "備考", "操作"].map((h, ci) => (
                      <th key={h} style={{ border: "1px solid #a7f3d0", padding: "8px 10px", textAlign: "left" }}>
                        <div style={{ display: "flex", alignItems: "center", gap: 8 }}>
                          <span>{h}</span>
                          {(ci === 1 || ci === 2 || ci === 3) && (
                            <button
                              onClick={() => copyColumn(ci)}
                              title={`${h}列をコピー（結合セル向け）`}
                              style={{ padding: "6px 10px", borderRadius: 8, border: "1px solid #a7f3d0", background: "#fff", color: "#047857", fontWeight: 600 }}
                            >
                              コピー
                            </button>
                          )}
                        </div>
                      </th>
                    ))}
                  </tr>
                </thead>
                <tbody>
                  {rows.length === 0 ? (
                    <tr>
                      <td colSpan={6} style={{ padding: 24, textAlign: "center", color: "#047857" }}>ここに結果が表示されます</td>
                    </tr>
                  ) : (
                    rows.map((r, idx) => (
                      <tr key={r.id} style={{ background: r.found ? "transparent" : "#fff7ed" }}>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", fontSize: 12 }}>{idx + 1}</td>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", whiteSpace: "nowrap" }}>
                          {inplaceEdit ? (
                            <input
                              value={r.model}
                              onChange={(e) => updateRow(r.id, "model", e.target.value)}
                              style={{ width: "100%", padding: "6px 8px", border: "1px solid #e5e7eb", borderRadius: 6 }}
                            />
                          ) : (
                            <span style={{ fontWeight: 600, color: "#064e3b" }}>{r.modelLabel && r.modelLabel !== r.model ? `品名・型式　${r.modelLabel}` : r.model}</span>
                          )}
                        </td>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", fontVariantNumeric: "tabular-nums" }}>
                          {inplaceEdit ? (
                            <input
                              value={r.listPrice}
                              onChange={(e) => updateRow(r.id, "listPrice", e.target.value)}
                              placeholder="定価"
                              style={{ width: "100%", padding: "6px 8px", border: "1px solid #e5e7eb", borderRadius: 6 }}
                            />
                          ) : r.listPrice ? (
                            <span>{jpYen(r.listPrice)}</span>
                          ) : (
                            <span style={{ color: "#9ca3af" }}>—</span>
                          )}
                        </td>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", fontVariantNumeric: "tabular-nums" }}>
                          {inplaceEdit ? (
                            <input
                              value={r.cost}
                              onChange={(e) => updateRow(r.id, "cost", e.target.value)}
                              placeholder="仕入"
                              style={{ width: "100%", padding: "6px 8px", border: "1px solid #e5e7eb", borderRadius: 6 }}
                            />
                          ) : r.cost ? (
                            <span>{jpYen(r.cost)}</span>
                          ) : (
                            <span style={{ color: "#9ca3af" }}>—</span>
                          )}
                        </td>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", fontSize: 12 }}>
                          {r.note ? (
                            <span style={{ color: r.found ? "#047857" : "#9a3412" }}>{r.note}</span>
                          ) : r.found ? (
                            <span style={{ color: "#047857" }}>一致</span>
                          ) : (
                            <span style={{ color: "#9a3412" }}>未一致</span>
                          )}
                        </td>
                        <td style={{ border: "1px solid #a7f3d0", padding: "8px 10px", fontSize: 12 }}>
                          <button onClick={() => deleteRow(r.id)} style={{ padding: "6px 10px", borderRadius: 8, border: "1px solid #fecaca", background: "#fff", color: "#b91c1c", fontWeight: 600 }}>削除</button>
                        </td>
                      </tr>
                    ))
                  )}
                </tbody>
              </table>
            </div>

            {/* 失敗時の手動コピー */}
            <CopyDialog open={copyUI.open} title={copyUI.title} text={copyUI.text} onClose={() => setCopyUI({ open: false, title: "", text: "" })} />
          </div>
        </section>

        <footer style={{ fontSize: 12, color: "#047857", marginTop: 24 }}>
          <ul style={{ margin: 0, paddingLeft: 16 }}>
            <li>
              CSVは <b>縦持ち: 型式, 定価, 仕入, 種別(SP/NR/HNR)</b> または <b>横持ち: 型式, SP定価, SP仕入, NR定価, NR仕入, HNR定価, HNR仕入</b>
              に対応。各種別で<b>最大2種類</b>を保持・表示します。
            </li>
            <li>
              <b>TNHS- / TEL / FAX / DSP3000 / PC / UL / COM</b> は自動で無視します。型式末尾の <b>( ... )</b> は照合時に無視します。
            </li>
            <li>ひらがな・漢字・カタカナ（全角・半角）を含む型式は読み込み対象外です。PDFはテキストベースのみ対応（画像ベースは抽出不可）。</li>
            <li>列コピーはヘッダの「コピー」ボタンから。失敗時は手動コピー用のダイアログが開きます。</li>
          </ul>
        </footer>
      </div>
      <Toast />
    </div>
  );
}

// ----------------------------------
// Minimal Smoke Tests（開発時のみ手動実行）
// window.__RUN_SMOKE_TESTS__ = true で実行
// ----------------------------------
function _runSmokeTests() {
  try {
    console.assert(normalizeKey("Abc- 123 (50Hz)") === "ABC123", "normalizeKey 失敗");
    const txt = "ABC-1 ABC-1 DEF-2(注記) ｱｲｳ-1 あいう-1 試験-1 TNHS-100 DSP3000";
    const list = parseModelList(txt);
    const abc1Count = list.filter((x) => x === "ABC-1").length;
    console.assert(abc1Count === 2, "parseModelList 重複保持 失敗");
    console.assert(list.includes("DEF-2"), "parseModelList 有効抽出 失敗");
    console.assert(!list.includes("ｱｲｳ-1"), "parseModelList 半角カタカナ除外 失敗");
    console.assert(!list.includes("あいう-1"), "parseModelList ひらがな除外 失敗");
    console.assert(!list.includes("試験-1"), "parseModelList 漢字除外 失敗");
    console.assert(!list.includes("DSP3000") && !list.includes("TNHS-100"), "parseModelList ノイズ除外 失敗");
    console.assert(jpYen("1000") === "1,000", "jpYen フォーマット 失敗");
    console.log("[SMOKE] jpYen:", [jpYen(0), jpYen("12,345"), jpYen("/98,765")]);
  } catch (e) {
    console.warn("[SMOKE] failed:", e);
  }
}

if (typeof window !== "undefined" && (window as any).__RUN_SMOKE_TESTS__ === true) {
  _runSmokeTests();
}
