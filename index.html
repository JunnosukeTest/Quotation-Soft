import React, { useCallback, useMemo, useRef, useState } from "react";
import { Toaster, toast } from "sonner";
import Papa from "papaparse";
import * as pdfjsLib from "pdfjs-dist";

// ★ bundler 依存を避けるため CDN の worker を使う
pdfjsLib.GlobalWorkerOptions.workerSrc =
  `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjsLib.version}/pdf.worker.min.js`;

// ---- Helpers ----
const jpYen = (n: any) => {
  const num = parseFloat(String(n ?? "").toString().replace(/[^0-9.-]/g, ""));
  if (isNaN(num)) return "";
  return new Intl.NumberFormat("ja-JP").format(num); // 単位は付けない
};

const stripParen = (s: any) => String(s ?? "").replace(/\([^)]*\)/g, "").trim();
const isNoise = (s: any) =>
  /^(TNHS-|TEL|FAX|PC|UL|COM)/i.test(String(s).trim()) || /^DSP3000$/i.test(String(s).trim());
const isValidModel = (s: any) => {
  const base = stripParen(s);
  if (!/^[A-Z]/.test(base)) return false;
  if (/[ァ-ヶー]/.test(base) || /[ｦ-ﾟ]/.test(base)) return false;
  return true;
};
const normalizeKey = (s: any) => stripParen(s).toUpperCase().replace(/[-\s]/g, "");

const parseModelList = (text: string) => {
  if (!text) return [];
  return text
    .split(/[\n,;\t\s]+/)
    .map((x) => stripParen(x))
    .map((x) => String(x).trim())
    .filter((x) => Boolean(x) && !isNoise(x) && isValidModel(x));
};

// クリップボード安全コピー（Permissions-Policy や 非HTTPS でもなるべく成功させる）
async function safeCopy(text: any) {
  const val = String(text ?? "");
  try {
    if (typeof navigator !== "undefined" && navigator.clipboard && typeof window !== "undefined" && window.isSecureContext) {
      await navigator.clipboard.writeText(val);
      return true;
    }
  } catch {}
  try {
    const ta = document.createElement("textarea");
    ta.value = val;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.top = "-1000px";
    ta.style.left = "-1000px";
    document.body.appendChild(ta);
    ta.focus();
    ta.select();
    ta.setSelectionRange(0, ta.value.length);
    const ok = (document as any).execCommand && (document as any).execCommand("copy");
    document.body.removeChild(ta);
    return !!ok;
  } catch {
    return false;
  }
}

function useSpCsvMap() {
  const [map, setMap] = useState<Map<string, any> | null>(null);
  const [meta, setMeta] = useState<any>(null);

  const load = useCallback(async (file: File) => {
    return new Promise<Map<string, any>>((resolve, reject) => {
      Papa.parse(file, {
        header: false,
        skipEmptyLines: true,
        complete: (res: any) => {
          const rows = res.data as any[];
          const m = new Map<string, any>();
          let kept = 0;

          for (const row of rows) {
            const rawModel = row?.[0];
            const listPrice = row?.[1] ?? "";
            const cost = row?.[2] ?? "";
            if (!rawModel) continue;

            const model = stripParen(rawModel);
            if (isNoise(model) || !isValidModel(model)) continue;

            const key = normalizeKey(model);
            const entry = m.get(key) || { model: String(model).trim(), variants: [] as any[] };

            const sig = String(listPrice) + "|||" + String(cost);
            const hasSame = entry.variants.some((v: any) => (String(v.listPrice) + "|||" + String(v.cost)) === sig);
            if (!hasSame && entry.variants.length < 2) {
              entry.variants.push({ listPrice, cost });
            }
            m.set(key, entry);
            kept++;
          }

          setMap(m);
          setMeta({ rows: rows.length, kept, uniqueKeys: m.size, fileName: file.name });
          resolve(m);
        },
        error: (err: any) => reject(err),
        encoding: "UTF-8",
      });
    });
  }, []);

  return { map, meta, load };
}

async function extractTextFromPdf(file: File) {
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
  let text = "";
  for (let i = 1; i <= pdf.numPages; i++) {
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    text += (content.items as any[]).map((it: any) => (it.str ? it.str + "\n" : "")).join("");
  }
  return text.trim();
}

function CopyBtn({ value }: { value: any }) {
  const onClick = useCallback(async () => {
    const ok = await safeCopy(value);
    ok ? toast.success("コピーしました") : toast.error("コピーできませんでした（ブラウザの制限）");
  }, [value]);
  return (
    <button type="button" onClick={onClick} style={{ marginLeft: 8, padding: "4px 8px", border: "1px solid #A7F3D0", borderRadius: 6, background: "#ECFDF5", color: "#047857" }}>
      コピー
    </button>
  );
}

function DropZone({ onFiles, accept = "*", label = "ここにファイルをドロップ / クリックで選択" }: { onFiles: (files: File[]) => void; accept?: string; label?: string; }) {
  const inputRef = useRef<HTMLInputElement | null>(null);
  const onDrop = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    const files = (e.dataTransfer.files && e.dataTransfer.files.length) ? Array.from(e.dataTransfer.files) : [];
    if (files.length) onFiles(files as File[]);
  }, [onFiles]);
  return (
    <div onDragOver={(e) => e.preventDefault()} onDrop={onDrop} onClick={() => inputRef.current?.click()}
      style={{ border: "2px dashed #6EE7B7", borderRadius: 16, padding: 16, textAlign: "center", cursor: "pointer", background: "white" }}>
      <p style={{ color: "#047857", fontSize: 12 }}>{label}</p>
      <input ref={inputRef} type="file" accept={accept} style={{ display: "none" }} onChange={(e) => onFiles(Array.from(e.target.files || []) as File[])} />
    </div>
  );
}

function genId(prefix = "ROW") {
  return `${prefix}-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

export default function App() {
  const { map: spMap, meta: spMeta, load: loadSp } = useSpCsvMap();
  const [pdfText, setPdfText] = useState("");
  const [loadingPdf, setLoadingPdf] = useState(false);
  const [rows, setRows] = useState<any[]>([]);
  const [inplaceEdit, setInplaceEdit] = useState(false);

  // ---- Priority helpers ----
  const buildRowsFromModels = useCallback((modelList: string[]) => {
    return modelList.flatMap((m, occIdx) => {
      const key = normalizeKey(m);
      const hit = spMap ? spMap.get(key) : null;
      const variants = hit?.variants?.length ? hit.variants.slice(0, 2) : [{ listPrice: "", cost: "" }];
      return variants.map((v: any, i: number) => ({
        id: `${key}-${occIdx}-${i}`,
        model: hit?.model || stripParen(m),
        listPrice: v.listPrice,
        cost: v.cost,
        found: Boolean(hit),
        note: hit ? "一致（SP）" : "未一致",
        show: true,
      }));
    });
  }, [spMap]);

  const resolvePricesFromCsv = useCallback((prevRows: any[]) => {
    if (!spMap) return prevRows;
    return prevRows.map((r) => {
      const key = normalizeKey(r.model || "");
      const hit = key ? spMap.get(key) : null;
      if (hit?.variants?.length) {
        const v = hit.variants[0];
        return { ...r, listPrice: v.listPrice, cost: v.cost, found: true, note: "一致（SP）" };
      }
      return { ...r, found: false, note: "未一致" };
    });
  }, [spMap]);

  const handleLoadSpCsv = useCallback(async (files: File[]) => {
    if (!files?.length) return;
    const file = files[0];
    if (!file.name.toLowerCase().endsWith(".csv")) return toast.error("CSVファイルを選択してください");
    try {
      await loadSp(file);
      toast.success("SP 価格マスタを読み込みました");
      setRows((prev) => resolvePricesFromCsv(prev)); // 1 優先
    } catch (e) {
      console.error(e);
      toast.error("CSVの読み込みに失敗しました");
    }
  }, [loadSp, resolvePricesFromCsv]);

  const handlePdfDrop = useCallback(async (files: File[]) => {
    if (!files?.length) return;
    const file = files[0];
    if (!(file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf"))) return toast.error("PDFファイルを選択してください");
    setLoadingPdf(true);
    try {
      const text = await extractTextFromPdf(file);
      if (!text) toast.error("画像ベースのため表示エラー（テキスト抽出不可）");
      setPdfText(text || "");
      if (text) {
        const nextModels = parseModelList(text);
        const nextRows = buildRowsFromModels(nextModels); // 2 優先 → 3 へ
        setRows(nextRows);
        setInplaceEdit(true);
        toast.message("PDFを優先して見積表を更新しました（2→3）");
      }
    } catch (e) {
      toast.error("PDF抽出に失敗しました");
    } finally {
      setLoadingPdf(false);
    }
  }, [buildRowsFromModels]);

  const models = useMemo(() => parseModelList(pdfText), [pdfText]);

  const addRow = useCallback(() => {
    setRows((prev) => [...prev, { id: genId(), model: "", listPrice: "", cost: "", found: false, note: "手入力", show: true }]);
  }, []);
  const deleteRow = useCallback((id: string) => setRows((prev) => prev.filter((r) => r.id !== id)), []);

  const handleEstimate = useCallback(() => {
    if (inplaceEdit) {
      if (!spMap) { toast.message("SPマスタ未読込のため反映スキップ"); setInplaceEdit(false); return; }
      setRows((prev) => resolvePricesFromCsv(prev)); // 3 で 1 を反映
      setInplaceEdit(false);
      toast.success("編集を確定し、CSVに基づく価格を反映しました（1優先）");
      return;
    }
    if (rows.length > 0) { setInplaceEdit(true); toast.message("直接編集モードに切替"); return; }
    if (!spMap) { toast.error("SP マスタ未読込です"); return; }
    if (!models.length) { toast.error("PDFから型式を抽出してください"); return; }
    const expanded = buildRowsFromModels(models);
    setRows(expanded);
    setInplaceEdit(true);
    toast.message("PDF結果を読み込み、直接編集モードに切替");
  }, [inplaceEdit, rows.length, spMap, models, buildRowsFromModels, resolvePricesFromCsv]);

  const updateRow = useCallback((id: string, key: "model" | "listPrice" | "cost", val: string) => {
    setRows((prev) => prev.map((r) => (r.id === id ? { ...r, [key]: val } : r)));
  }, []);

  return (
    <div style={{ minHeight: "100vh", background: "white" }}>
      <div style={{ maxWidth: 960, margin: "0 auto", padding: 24 }}>
        <header style={{ marginBottom: 24, display: "flex", justifyContent: "space-between", alignItems: "center" }}>
          <h1 style={{ fontSize: 20, fontWeight: 700, color: "#065F46" }}>価格表示ツール（SP版）</h1>
          <div style={{ fontSize: 12, color: "#047857" }}>背景：白 / 基調：ライトグリーン</div>
        </header>

        <section style={{ border: "1px solid #A7F3D0", borderRadius: 12, marginBottom: 16, padding: 16 }}>
          <h2 style={{ marginBottom: 8, color: "#065F46" }}>1. SP価格マスタCSVの読み込み</h2>
          <DropZone accept=".csv" onFiles={handleLoadSpCsv} label={"SP.csv をドロップ / クリックで選択（A=型式, B=定価, C=仕入）"} />
          {spMeta && (
            <div style={{ fontSize: 12, color: "#047857", marginTop: 8 }}>
              {spMeta.fileName} / 有効行: {spMeta.kept} / 一意型式: {spMeta.uniqueKeys}件
            </div>
          )}
        </section>

        <section style={{ border: "1px solid #A7F3D0", borderRadius: 12, marginBottom: 16, padding: 16 }}>
          <h2 style={{ marginBottom: 8, color: "#065F46" }}>2. 型式の入力（PDF抽出）</h2>
          <DropZone accept="application/pdf,.pdf" onFiles={handlePdfDrop} label="PDFをドロップ / クリックで選択（画像ベースはエラー表示）" />
          <div style={{ fontSize: 12, color: "#047857", marginTop: 8 }}>
            {loadingPdf ? "抽出中..." : pdfText ? `${pdfText.slice(0, 80)}...` : ""}
          </div>
        </section>

        <section style={{ border: "1px solid #A7F3D0", borderRadius: 12, marginBottom: 16, padding: 16 }}>
          <h2 style={{ marginBottom: 8, color: "#065F46" }}>3. 価格表の表示（SP／重複は上下2段表示）</h2>

          <div style={{ display: "flex", gap: 8, marginBottom: 12 }}>
            {inplaceEdit && (
              <button type="button" onClick={addRow} style={{ padding: "6px 10px", border: "1px solid #A7F3D0", borderRadius: 6, background: "white", color: "#047857" }}>
                行を追加
              </button>
            )}
            <button type="button" onClick={handleEstimate} style={{ marginLeft: "auto", padding: "6px 10px", borderRadius: 6, background: "#059669", color: "white", border: "none" }}>
              {inplaceEdit ? "決定（見積表示）" : rows.length > 0 ? "再編集（見積表示）" : "見積表示"}
            </button>
          </div>

          <div style={{ overflow: "auto", border: "1px solid #A7F3D0", borderRadius: 12 }}>
            <table style={{ width: "100%", fontSize: 14 }}>
              <thead style={{ background: "#ECFDF5", color: "#065F46" }}>
                <tr>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>項目</th>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>型式</th>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>定価</th>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>仕入</th>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>備考</th>
                  <th style={{ textAlign: "left", padding: "6px 8px" }}>操作</th>
                </tr>
              </thead>
              <tbody>
                {rows.length === 0 ? (
                  <tr>
                    <td colSpan={6} style={{ textAlign: "center", padding: 16, color: "#047857" }}>ここに結果が表示されます</td>
                  </tr>
                ) : rows.map((r, idx) => (
                  <tr key={r.id} style={{ background: r.found ? "white" : "#FFF7ED" }}>
                    <td style={{ padding: "6px 8px", fontSize: 12 }}>{idx + 1}</td>
                    <td style={{ padding: "6px 8px", whiteSpace: "nowrap" }}>
                      {inplaceEdit ? (
                        <input style={{ width: "100%", padding: "6px", border: "1px solid #D1D5DB", borderRadius: 6 }} value={r.model} onChange={(e) => updateRow(r.id, "model", e.target.value)} />
                      ) : (
                        <span style={{ fontWeight: 600, color: "#065F46" }}>{r.model}</span>
                      )}
                      {!inplaceEdit && <CopyBtn value={r.model} />}
                    </td>
                    <td style={{ padding: "6px 8px" }}>
                      {inplaceEdit ? (
                        <input style={{ width: "100%", padding: "6px", border: "1px solid #D1D5DB", borderRadius: 6 }} value={r.listPrice} onChange={(e) => updateRow(r.id, "listPrice", e.target.value)} placeholder="定価" />
                      ) : r.listPrice ? <span>{jpYen(r.listPrice)}</span> : <span style={{ color: "#9CA3AF" }}>—</span>}
                      {!inplaceEdit && r.listPrice && <CopyBtn value={jpYen(r.listPrice)} />}
                    </td>
                    <td style={{ padding: "6px 8px" }}>
                      {inplaceEdit ? (
                        <input style={{ width: "100%", padding: "6px", border: "1px solid #D1D5DB", borderRadius: 6 }} value={r.cost} onChange={(e) => updateRow(r.id, "cost", e.target.value)} placeholder="仕入" />
                      ) : r.cost ? <span>{jpYen(r.cost)}</span> : <span style={{ color: "#9CA3AF" }}>—</span>}
                      {!inplaceEdit && r.cost && <CopyBtn value={jpYen(r.cost)} />}
                    </td>
                    <td style={{ padding: "6px 8px", fontSize: 12 }}>
                      {r.note ? <span style={{ color: "#047857" }}>{r.note}</span> : r.found ? <span style={{ color: "#047857" }}>一致（SP）</span> : <span style={{ color: "#9A3412" }}>未一致</span>}
                    </td>
                    <td style={{ padding: "6px 8px", fontSize: 12 }}>
                      <button type="button" onClick={() => deleteRow(r.id)} style={{ padding: "4px 8px", border: "1px solid #FCA5A5", borderRadius: 6, background: "white", color: "#B91C1C" }}>
                        削除
                      </button>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </section>

        <footer style={{ fontSize: 12, color: "#047857", marginTop: 24 }}>
          <ul>
            <li>CSVは <b>A=型式, B=定価, C=仕入</b>（同一型式で異なる金額がある場合は最大2種類を保持）</li>
            <li><b>TNHS-</b> / <b>TEL</b> / <b>FAX</b> / <b>DSP3000</b> / <b>PC</b> / <b>UL</b> / <b>COM</b> 始まりは自動で無視</li>
            <li>型式末尾の <b>( ... )</b> は無視して照合</li>
            <li>PDFはテキストベースのみ対応（画像ベースは抽出不可）</li>
          </ul>
        </footer>

        {/* sonner toaster */}
        <Toaster richColors position="top-right" />
      </div>
    </div>
  );
}
