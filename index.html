import React, { useCallback, useMemo, useRef, useState } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "sonner";
import Papa from "papaparse";
import * as pdfjsLib from "pdfjs-dist";
import "pdfjs-dist/build/pdf.worker.mjs";

// ---- Helpers ----
const jpYen = (n) => {
  const num = parseFloat(String(n ?? "").toString().replace(/[^0-9.-]/g, ""));
  if (isNaN(num)) return "";
  return new Intl.NumberFormat("ja-JP").format(num) + "円";
};

// ()内注記を無視した型式に整形
const stripParen = (s) => String(s ?? "").replace(/\([^)]*\)/g, "").trim();

// ノイズ判定: TNHS-*, TEL*, FAX*, DSP3000
const isNoise = (s) =>
  /^(TNHS-|TEL|FAX)/i.test(String(s).trim()) ||
  /^DSP3000$/i.test(String(s).trim());

// 型式抽出: 先頭が大文字アルファベット以外、カタカナ（全角/半角）を含むものは除外
const isValidModel = (s) => {
  const base = stripParen(s);
  if (!/^[A-Z]/.test(base)) return false;
  // 全角カタカナ: [ァ-ヶー]、半角カタカナ: [ｦ-ﾟ]
  if (/[ァ-ヶー]/.test(base) || /[ｦ-ﾟ]/.test(base)) return false;
  return true; // 半角数字はOK
};

// キー正規化（大文字化・ハイフン/空白除去・()内削除）
const normalizeKey = (s) => stripParen(s)
  .toUpperCase()
  .replace(/[-\s]/g, "");

const parseModelList = (text) => {
  if (!text) return [];
  return Array.from(
    new Set(
      text
        .split(/[\n,;\t\s]+/)
        .map((x) => stripParen(x))
        .map((x) => x.trim())
        .filter((x) => Boolean(x) && !isNoise(x) && isValidModel(x))
    )
  );
};

function useSpCsvMap() {
  const [map, setMap] = useState(null);
  const [meta, setMeta] = useState(null);

  const load = useCallback(async (file) => {
    return new Promise((resolve, reject) => {
      Papa.parse(file, {
        header: false,
        skipEmptyLines: true,
        complete: (res) => {
          const rows = res.data;
          const m = new Map();
          let kept = 0;
          for (const row of rows) {
            const rawModel = row?.[0];
            const listPrice = row?.[1] ?? "";
            const cost = row?.[2] ?? "";
            if (!rawModel) continue;
            const model = stripParen(rawModel);
            if (isNoise(model) || !isValidModel(model)) continue;
            const key = normalizeKey(model);
            const entry = m.get(key) || { model: String(model).trim(), variants: [] };
            // 同一金額ペア重複を避け、最大2件まで保持
            const sig = String(listPrice) + "|||" + String(cost);
            const hasSame = entry.variants.some((v) => (String(v.listPrice) + "|||" + String(v.cost)) === sig);
            if (!hasSame && entry.variants.length < 2) {
              entry.variants.push({ listPrice, cost });
            }
            m.set(key, entry);
            kept++;
          }
          setMap(m);
          setMeta({ rows: rows.length, kept, uniqueKeys: m.size, fileName: file.name });
          resolve(m);
        },
        error: (err) => reject(err),
        encoding: "UTF-8",
      });
    });
  }, []);

  return { map, meta, load };
}

async function extractTextFromPdf(file) {
  try {
    const buf = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: buf }).promise;
    let text = "";
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const content = await page.getTextContent();
      text += content.items.map((it) => (it.str ? it.str + "\n" : "")).join("");
    }
    return text.trim();
  } catch (e) {
    console.error(e);
    throw e;
  }
}

function CopyBtn({ value, label = "コピー" }) {
  return (
    <Button
      variant="secondary"
      className="ml-2 bg-emerald-50 hover:bg-emerald-100 text-emerald-700 border border-emerald-200"
      onClick={async () => {
        try {
          await navigator.clipboard.writeText(String(value ?? ""));
          toast.success(`${label}しました`);
        } catch (e) {
          toast.error("コピーに失敗しました");
        }
      }}
    >
      {label}
    </Button>
  );
}

function DropZone({ onFiles, accept = "*", label = "ここにファイルをドロップ / クリックで選択" }) {
  const inputRef = useRef(null);
  const onDrop = useCallback(
    (e) => {
      e.preventDefault();
      const files = e.dataTransfer.files;
      if (files && files.length) onFiles(Array.from(files));
    },
    [onFiles]
  );
  return (
    <div
      onDragOver={(e) => e.preventDefault()}
      onDrop={onDrop}
      onClick={() => inputRef.current?.click()}
      className="w-full border-2 border-dashed rounded-2xl p-6 text-center cursor-pointer bg-white hover:bg-emerald-50 border-emerald-300"
    >
      <p className="text-sm text-emerald-700">{label}</p>
      <input
        ref={inputRef}
        type="file"
        accept={accept}
        className="hidden"
        onChange={(e) => onFiles(Array.from(e.target.files || []))}
      />
    </div>
  );
}

export default function App() {
  const { map: spMap, meta: spMeta, load: loadSp } = useSpCsvMap();

  const [pdfText, setPdfText] = useState("");
  const [loadingPdf, setLoadingPdf] = useState(false);
  const [results, setResults] = useState([]);

  const handleLoadSpCsv = useCallback(async (files) => {
    if (!files?.length) return;
    const file = files[0];
    const ok = file.name.toLowerCase().endsWith(".csv");
    if (!ok) return toast.error("CSVファイルを選択してください");
    try {
      await loadSp(file);
      toast.success("SP 価格マスタ（型式・定価・仕入 最大2種）を読み込みました");
    } catch (e) {
      console.error(e);
      toast.error("CSVの読み込みに失敗しました");
    }
  }, [loadSp]);

  const handlePdfDrop = useCallback(async (files) => {
    if (!files?.length) return;
    const file = files[0];
    const ok = file.type === "application/pdf" || file.name.toLowerCase().endsWith(".pdf");
    if (!ok) return toast.error("PDFファイルを選択してください");
    setLoadingPdf(true);
    try {
      const text = await extractTextFromPdf(file);
      if (!text) {
        toast.error("画像ベースのため表示エラー（テキスト抽出不可）");
      }
      setPdfText(text || "");
      if (text) toast.success("PDFからテキストを抽出しました");
    } catch (e) {
      toast.error("PDF抽出に失敗しました（画像ベースの可能性）");
    } finally {
      setLoadingPdf(false);
    }
  }, []);

  const models = useMemo(() => {
    return parseModelList(pdfText);
  }, [pdfText]);

  const handleEstimate = useCallback(() => {
    if (!spMap) {
      toast.error("SP の価格マスタが未読込です");
      return;
    }
    if (!models.length) {
      toast.error("PDFから型式を抽出してください");
      return;
    }
    const rows = models.map((m) => {
      const key = normalizeKey(m);
      const hit = spMap.get(key);
      return {
        input: m,
        model: hit?.model || stripParen(m),
        variants: hit?.variants || [], // up to 2
        found: !!hit,
      };
    });
    setResults(rows);
  }, [spMap, models]);

  return (
    <div className="min-h-screen bg-white">
      <div className="mx-auto max-w-6xl p-6">
        <header className="mb-6 flex items-center justify-between">
          <h1 className="text-2xl font-bold text-emerald-800">価格表示ツール（SP版）</h1>
          <div className="text-xs text-emerald-700">背景：白 / 基調：ライトグリーン</div>
        </header>

        <Card className="mb-6 border-emerald-200">
          <CardHeader>
            <CardTitle className="text-emerald-800">1. SP価格マスタCSVの読み込み（型式・定価・仕入／重複は最大2種類）</CardTitle>
          </CardHeader>
          <CardContent className="grid grid-cols-1 gap-4">
            <div className="space-y-2">
              <DropZone
                accept=".csv"
                onFiles={handleLoadSpCsv}
                label={`SP.csv をドロップ / クリックで選択（A=型式, B=定価, C=仕入）`}
              />
              {spMeta && (
                <div className="text-xs text-emerald-700">
                  {spMeta.fileName} / 有効行: {spMeta.kept} / 一意型式: {spMeta.uniqueKeys}件
                </div>
              )}
            </div>
          </CardContent>
        </Card>

        <Card className="mb-6 border-emerald-200">
          <CardHeader>
            <CardTitle className="text-emerald-800">2. 型式の入力（PDF抽出）</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-3">
              <div className="text-sm font-medium text-emerald-900 mb-1">PDF（テキストベースのみ）</div>
              <DropZone
                accept="application/pdf,.pdf"
                onFiles={handlePdfDrop}
                label="PDFをドロップ / クリックで選択（画像ベースはエラー表示）"
              />
              <div className="text-xs text-emerald-700">
                {loadingPdf ? "抽出中..." : pdfText ? `${pdfText.slice(0, 80)}...` : ""}
              </div>
            </div>
          </CardContent>
        </Card>

        <Card className="mb-4 border-emerald-200">
          <CardHeader>
            <CardTitle className="text-emerald-800">3. 価格表の表示（SP／重複は上下2段表示）</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex flex-wrap items-center gap-3 mb-4">
              <Button
                className="ml-auto bg-emerald-600 hover:bg-emerald-700 text-white"
                onClick={handleEstimate}
              >
                見積表示
              </Button>
            </div>

            <div className="overflow-auto rounded-xl border border-emerald-200">
              <table className="w-full text-sm">
                <thead className="bg-emerald-50 text-emerald-900">
                  <tr>
                    <th className="px-3 py-2 text-left">型式</th>
                    <th className="px-3 py-2 text-left">定価</th>
                    <th className="px-3 py-2 text-left">仕入</th>
                    <th className="px-3 py-2 text-left">備考</th>
                  </tr>
                </thead>
                <tbody>
                  {results.length === 0 ? (
                    <tr>
                      <td colSpan={4} className="px-3 py-6 text-center text-emerald-700">ここに結果が表示されます</td>
                    </tr>
                  ) : (
                    results.flatMap((r, idx) => {
                      const variants = r.variants && r.variants.length ? r.variants : [{ listPrice: "", cost: "" }];
                      return variants.slice(0, 2).map((v, i) => (
                        <tr key={`${idx}-${i}`} className={r.found ? "" : "bg-orange-50"}>
                          <td className="px-3 py-2 whitespace-nowrap">
                            <span className="font-medium text-emerald-900">{r.model}{variants.length > 1 ? (i === 0 ? " (①)" : " (②)") : ""}</span>
                          </td>
                          <td className="px-3 py-2">
                            {v.listPrice ? <span>{jpYen(v.listPrice)}</span> : <span className="text-gray-400">—</span>}
                          </td>
                          <td className="px-3 py-2">
                            {v.cost ? <span>{jpYen(v.cost)}</span> : <span className="text-gray-400">—</span>}
                          </td>
                          <td className="px-3 py-2 text-xs">
                            {r.found ? <span className="text-emerald-700">一致（SP）</span> : <div className="text-orange-700">未一致</div>}
                          </td>
                        </tr>
                      ));
                    })
                  )}
                </tbody>
              </table>
            </div>
          </CardContent>
        </Card>

        <footer className="text-xs text-emerald-700 mt-6">
          <ul className="list-disc pl-4 space-y-1">
            <li>CSVは <b>A=型式, B=定価, C=仕入</b>。同一型式で異なる金額がある場合は<b>最大2種類</b>を保持・表示します。</li>
            <li><b>TNHS-</b> で始まる見積番号、<b>TEL</b>・<b>FAX</b>、<b>DSP3000</b> は自動で無視します。</li>
            <li>型式末尾の <b>( ... )</b> は無視して照合します（例：ABC-123 (50Hz) → ABC-123）。</li>
            <li>カタカナ（全角・半角）を含む型式は読み込み対象外です。</li>
            <li>PDFはテキストベースのみ対応。画像ベースPDFは抽出不可です。</li>
          </ul>
        </footer>
      </div>
    </div>
  );
}
